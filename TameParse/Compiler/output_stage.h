//
//  output_stage.h
//  Parse
//
//  Created by Andrew Hunter on 29/08/2011.
//  Copyright 2011 Andrew Hunter. All rights reserved.
//

#ifndef _COMPILER_OUTPUT_STAGE_H
#define _COMPILER_OUTPUT_STAGE_H

#include <string>
#include <vector>

#include "TameParse/Dfa/range.h"

#include "TameParse/ContextFree/grammar.h"
#include "TameParse/ContextFree/terminal_dictionary.h"

#include "TameParse/Lr/lalr_builder.h"
#include "TameParse/Lr/parser_tables.h"

#include "TameParse/Compiler/output_stage_data.h"
#include "TameParse/Compiler/compilation_stage.h"
#include "TameParse/Compiler/language_stage.h"
#include "TameParse/Compiler/lr_parser_stage.h"
#include "TameParse/Compiler/lexer_stage.h"

namespace compiler {
	///
	/// \brief Base class for a compilation stage that produces output in a given language
	///
	class output_stage : public compilation_stage {
	private:
		/// \brief The lexer stage that should be compiled
		lexer_stage* m_LexerStage;

		/// \brief The language stage that should be compiled
		language_stage* m_LanguageStage;

		/// \brief The LR parser that should be compiled
		lr_parser_stage* m_ParserStage;

	public:
		/// \brief Creates a new output stage
		output_stage(console_container& console, const std::wstring& filename, lexer_stage* lexer, language_stage* language, lr_parser_stage* parser);

		/// \brief Destructor
		virtual ~output_stage();

		/// \brief Compiles the parser specified by this stage
		///
		/// Subclasses can override this if they want to substantially change the way that the
		/// compiler is generated.
		virtual void compile();

	protected:
		// Higher-level stages of the process

		/// \brief Defines the symbols associated with this language
		virtual void define_symbols();

		/// \brief Writes out the lexer tables (the symbol map and the state table)
		virtual void define_lexer_tables();

		/// \brief Writes out the parser tables
		virtual void define_parser_tables();

		/// \brief Writes out the AST tables
		virtual void define_ast_tables();

	protected:
		// Data structures used by this stage
		//
		// Basic idea is that we reformat the data generated by the parser and lexer
		// generators into a format that's easy to write out into a language
		// definition.

		typedef data::terminal_symbol 						terminal_symbol;
		typedef data::nonterminal_symbol 					nonterminal_symbol;
		typedef data::symbol_map 							symbol_map;
		typedef data::lexer_state_transition 				lexer_state_transition;
		typedef data::lexer_state_action 					lexer_state_action;

		typedef std::vector<terminal_symbol>				terminal_symbol_list;
		typedef std::vector<nonterminal_symbol>				nonterminal_symbol_list;
		typedef std::vector<symbol_map>						symbol_map_list;
		typedef std::vector<lexer_state_transition>			lexer_state_transition_list;
		typedef std::vector<lexer_state_action>				lexer_state_action_list;

		typedef terminal_symbol_list::const_iterator		terminal_symbol_iterator;
		typedef nonterminal_symbol_list::const_iterator		nonterminal_symbol_iterator;
		typedef symbol_map_list::const_iterator				symbol_map_iterator;
		typedef lexer_state_transition_list::const_iterator	lexer_state_transition_iterator;
		typedef lexer_state_action_list::const_iterator		lexer_state_action_iterator;

	private:
		// Storage members (empty if not generated yet)

		terminal_symbol_list 			m_TerminalSymbols;
		nonterminal_symbol_list			m_NonterminalSymbols;

		symbol_map_list 				m_LexerSymbolMap;
		lexer_state_transition_list		m_LexerTransitions;
		lexer_state_action_list			m_LexerActions;

	private:
		// Generate storage data

		void generate_terminal_symbols();
		void generate_nonterminal_symbols();

		void generate_lexer_symbol_map();
		void generate_lexer_transitions();
		void generate_lexer_actions();

	protected:
		// Functions that represent various steps of the output of a language.
		// These are intended to make it easy to write out a file in the specified language.
		// They do nothing in this base class (but they are not abstract)
		//
		// You can override compile() or the define_x methods to get more fine-grained control

		/// \brief About to begin writing out output
		virtual void begin_output();

		/// \brief Finishing writing out output
		virtual void end_output();

		/// \brief The grammar for the language that should be written
		inline const contextfree::grammar& gram() { return *m_LanguageStage->grammar(); }

		/// \brief The first terminal symbol
		terminal_symbol_iterator begin_terminal_symbol();

		/// \brief The symbol after the final terminal symbol
		terminal_symbol_iterator end_terminal_symbol();

		/// \brief The first nonterminal symbol
		nonterminal_symbol_iterator begin_nonterminal_symbol();

		/// \brief The symbol after the final nonterminal symbol
		nonterminal_symbol_iterator end_nonterminal_symbol();

		// TODO: add 'other' symbols (EBNF items, guards, etc)

		/// \brief The number of symbol sets defined in the lexer
		inline int count_lexer_symbol_sets() { return m_LexerStage->dfa()->symbols().count_sets(); }

		/// \brief The total number of states in the lexer
		inline int count_lexer_states() { return m_LexerStage->dfa()->count_states(); }

		/// \brief The first item in the symbol map
		symbol_map_iterator begin_symbol_map();

		/// \brief The item after the final item in the symbol map
		symbol_map_iterator end_symbol_map();

		/// \brief The first lexer state transition
		///
		/// Lexer state transitions are returned in sorted order (by state, then by symbol set ID)
		lexer_state_transition_iterator begin_lexer_state_transition();

		/// \brief The final lexer state transition
		lexer_state_transition_iterator end_lexer_state_transition();

		/// \brief The first lexer state action
		///
		/// Actions are returned ordered by state
		lexer_state_action_iterator begin_lexer_state_action();

		/// \brief The final lexer state action
		lexer_state_action_iterator end_lexer_state_action();

		/// \brief Starting to write out the definitions associated with the parser
		virtual void begin_parser_definitions();

		// TODO: maybe provide some fine-grained table generation?

		/// \brief Supplies the parser tables generated by the compiler
		virtual void parser_tables(const lr::lalr_builder& builder, const lr::parser_tables& tables);

		/// \brief Finished the parser definitions
		virtual void end_parser_definitions();

		/// \brief Starting to write out the definitions associated with the AST
		virtual void begin_ast_definitions(const contextfree::grammar& grammar, const contextfree::terminal_dictionary& terminals);

		/// \brief Starting to write the AST definitions for a particular terminal symbol
		virtual void begin_ast_terminal(int symbolId, const contextfree::item_container& item);

		/// \brief Finished writing the definitions for a terminal
		virtual void end_ast_terminal();

		/// \brief Starting to write the AST definitions for the specified nonterminal
		virtual void begin_ast_nonterminal(int identifier, const contextfree::item_container& item);

		/// \brief Starting to write out a rule in the current nonterminal
		virtual void begin_ast_rule(int identifier);

		/// \brief Writes out an individual item in the current rule (a nonterminal)
		virtual void rule_item_nonterminal(int nonterminalId, const contextfree::item_container& item);
        
        /// \brief Writes out an individual item in the current rule (a terminal)
        ///
        /// Note the distinction between the item ID, which is part of the grammar, and the
        /// symbol ID (which is part of the lexer and is the same as the value passed to 
        /// terminal_symbol)
        virtual void rule_item_terminal(int terminalItemId, int terminalSymbolId, const contextfree::item_container& item);

		/// \brief Finished writing out 
		virtual void end_ast_rule();

		/// \brief Finished writing the definitions for a nonterminal
		virtual void end_ast_nonterminal();

		/// \brief Finished writing out the AST information
		virtual void end_ast_definitions();
	};
}

#endif
