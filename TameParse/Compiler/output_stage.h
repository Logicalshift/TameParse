//
//  output_stage.h
//  Parse
//
//  Created by Andrew Hunter on 29/08/2011.
//  Copyright 2011-2012 Andrew Hunter. All rights reserved.
//

#ifndef _COMPILER_OUTPUT_STAGE_H
#define _COMPILER_OUTPUT_STAGE_H

#include <string>
#include <vector>

#include "TameParse/Dfa/range.h"

#include "TameParse/ContextFree/grammar.h"
#include "TameParse/ContextFree/terminal_dictionary.h"

#include "TameParse/Lr/lalr_builder.h"
#include "TameParse/Lr/parser_tables.h"

#include "TameParse/Compiler/output_stage_data.h"
#include "TameParse/Compiler/compilation_stage.h"
#include "TameParse/Compiler/language_stage.h"
#include "TameParse/Compiler/lr_parser_stage.h"
#include "TameParse/Compiler/lexer_stage.h"

namespace compiler {
    ///
    /// \brief Base class for a compilation stage that produces output in a given language
    ///
    class output_stage : public compilation_stage {
    private:
        /// \brief The lexer stage that should be compiled
        lexer_stage* m_LexerStage;

        /// \brief The language stage that should be compiled
        language_stage* m_LanguageStage;

        /// \brief The LR parser that should be compiled
        lr_parser_stage* m_ParserStage;

    public:
        /// \brief Creates a new output stage
        output_stage(console_container& console, const std::wstring& filename, lexer_stage* lexer, language_stage* language, lr_parser_stage* parser);

        /// \brief Destructor
        virtual ~output_stage();

        /// \brief Compiles the parser specified by this stage
        ///
        /// Subclasses can override this if they want to substantially change the way that the
        /// compiler is generated.
        virtual void compile();

    protected:
        // Higher-level stages of the process

        /// \brief Defines the symbols associated with this language
        virtual void define_symbols();

        /// \brief Writes out the lexer tables (the symbol map and the state table)
        virtual void define_lexer_tables();

        /// \brief Writes out the parser tables
        virtual void define_parser_tables();

        /// \brief Writes out the AST tables
        virtual void define_ast_tables();

    public:
        // Data structures used by this stage
        //
        // Basic idea is that we reformat the data generated by the parser and lexer
        // generators into a format that's easy to write out into a language
        // definition.

        typedef data::terminal_symbol                       terminal_symbol;
        typedef data::nonterminal_symbol                    nonterminal_symbol;
        typedef data::symbol_map                            symbol_map;
        typedef data::lexer_state_transition                lexer_state_transition;
        typedef data::lexer_state_action                    lexer_state_action;
        typedef data::ast_nonterminal                       ast_nonterminal;
        typedef data::ast_rule_item_list                    ast_rule_item_list;
        typedef data::ast_nonterminal_rules                 ast_nonterminal_rules;
        typedef data::ast_rule_item                         ast_rule_item;

        typedef std::vector<terminal_symbol>                terminal_symbol_list;
        typedef std::vector<nonterminal_symbol>             nonterminal_symbol_list;
        typedef std::vector<symbol_map>                     symbol_map_list;
        typedef std::vector<lexer_state_transition>         lexer_state_transition_list;
        typedef std::vector<lexer_state_action>             lexer_state_action_list;

        typedef terminal_symbol_list::const_iterator        terminal_symbol_iterator;
        typedef nonterminal_symbol_list::const_iterator     nonterminal_symbol_iterator;
        typedef symbol_map_list::const_iterator             symbol_map_iterator;
        typedef lexer_state_transition_list::const_iterator lexer_state_transition_iterator;
        typedef lexer_state_action_list::const_iterator     lexer_state_action_iterator;
        typedef ast_rule_item_list::const_iterator          ast_rule_item_iterator;
        typedef ast_nonterminal_rules::const_iterator       ast_nonterminal_rules_iterator;

    private:
        // Storage members (empty if not generated yet)

        terminal_symbol_list            m_TerminalSymbols;
        nonterminal_symbol_list         m_NonterminalSymbols;

        symbol_map_list                 m_LexerSymbolMap;
        lexer_state_transition_list     m_LexerTransitions;
        lexer_state_action_list         m_LexerActions;

        std::vector<ast_nonterminal>    m_RulesForNonterminal;

    private:
        // Generate storage data

        void generate_terminal_symbols();
        void generate_nonterminal_symbols();

        void generate_lexer_symbol_map();
        void generate_lexer_transitions();
        void generate_lexer_actions();

        void generate_ast_rules();

    protected:
        /// \brief Returns a name for a grammar rule
        std::wstring name_for_rule(const contextfree::rule_container& thisRule);

        /// \brief Gets a string name that can be used to represent a specific grammar item
        std::wstring name_for_ebnf_item(const contextfree::ebnf& item);

        /// \brief Gets a string name that can be used to represent a specific grammar item
        std::wstring name_for_item(const contextfree::item_container& item);

        /// \brief Returns true if the specified name should be considered 'valid'
        ///
        /// This is used when generating unique names for rules (and may be used in
        /// other places where a unique name is required)
        virtual bool name_is_valid(const std::wstring& name);

    protected:
        // Functions that represent various steps of the output of a language.
        // These are intended to make it easy to write out a file in the specified language.
        // They do nothing in this base class (but they are not abstract)
        //
        // You can override compile() or the define_x methods to get more fine-grained control

        /// \brief About to begin writing out output
        virtual void begin_output();

        /// \brief Finishing writing out output
        virtual void end_output();

        /// \brief The name of the language that will be produced by this stage
        std::wstring language_name();

        /// \brief The grammar for the language that should be written
        inline const contextfree::grammar& gram() { return *m_LanguageStage->grammar(); }

        /// \brief The dictionary of terminal items
        inline const contextfree::terminal_dictionary& terminals() { return *m_LanguageStage->terminals(); }

        /// \brief The first terminal symbol
        terminal_symbol_iterator begin_terminal_symbol();

        /// \brief The symbol after the final terminal symbol
        terminal_symbol_iterator end_terminal_symbol();

        /// \brief The first nonterminal symbol
        nonterminal_symbol_iterator begin_nonterminal_symbol();

        /// \brief The symbol after the final nonterminal symbol
        nonterminal_symbol_iterator end_nonterminal_symbol();

        // TODO: add 'other' symbols (EBNF items, guards, etc)

        /// \brief The number of symbol sets defined in the lexer
        inline int count_lexer_symbol_sets() { return m_LexerStage->dfa()->symbols().count_sets(); }

        /// \brief The total number of states in the lexer
        inline int count_lexer_states() { return m_LexerStage->dfa()->count_states(); }

        /// \brief The first item in the symbol map
        symbol_map_iterator begin_symbol_map();

        /// \brief The item after the final item in the symbol map
        symbol_map_iterator end_symbol_map();

        /// \brief The DFA for the lexer generated by the language
        const dfa::ndfa* get_dfa() const { return m_LexerStage->dfa(); }

        /// \brief The first lexer state transition
        ///
        /// Lexer state transitions are returned in sorted order (by state, then by symbol set ID)
        lexer_state_transition_iterator begin_lexer_state_transition();

        /// \brief The final lexer state transition
        lexer_state_transition_iterator end_lexer_state_transition();

        /// \brief The first lexer state action
        ///
        /// Actions are returned ordered by state
        lexer_state_action_iterator begin_lexer_state_action();

        /// \brief The final lexer state action
        lexer_state_action_iterator end_lexer_state_action();

        /// \brief The LALR parser builder object
        inline const lr::lalr_builder& get_lalr_builder() { return *m_ParserStage->get_parser(); }

        /// \brief The parser tables built by the parser generator
        inline const lr::parser_tables& get_parser_tables() { return *m_ParserStage->get_tables(); }

        /// \brief Returns the AST definition for the specified nonterminal
        const ast_nonterminal& get_ast_nonterminal(int nonterminalId);
    };
}

#endif
