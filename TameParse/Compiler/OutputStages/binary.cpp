//
//  binary.cpp
//  TameParse
//
//  Created by Andrew Hunter on 06/02/2012.
//  Copyright (c) 2012 Andrew Hunter. All rights reserved.
//

#include <cstdlib>
#include "TameParse/Compiler/OutputStages/binary.h"
#include "TameParse/version.h"

using namespace std;
using namespace dfa;
using namespace tameparse;
using namespace compiler;

/// \brief Creates a new output stage
output_binary::output_binary(console_container& console, const std::wstring& sourceFilename, lexer_stage* lexer, language_stage* language, lr_parser_stage* parser, const std::wstring& targetFile, bool bigEndian)
: output_stage(console, sourceFilename, lexer, language, parser)
, m_File(NULL)
, m_WritePos(0)
, m_FileLength(0)
, m_BigEndian(bigEndian) 
, m_TargetFilename(targetFile) {
}

/// \brief Destructor
output_binary::~output_binary() {
	// Free up the file if it exists
	if (m_File) {
		free(m_File);
		m_File = NULL;
	}
}

/// ==================
///  Raw file writing
/// ==================

/// \brief Retrieves a string associated with this binary file
int32_t output_binary::get_string(const std::wstring& value) {
	// Try to find the existing string
	map<wstring, int32_t>::iterator found = m_StringIdentifiers.find(value);

	// Use the existing ID if there is one
	if (found != m_StringIdentifiers.end()) {
		return found->second;
	}

	// Create a new ID
	int32_t newId = (int32_t) m_StringIdentifiers.size();
	m_StringIdentifiers[value] = newId;

	return newId;
}

/// \brief Writes out an integer value at the specified position
static inline void write_int_raw(uint32_t val, uint8_t*& file, size_t writePos, size_t& fileLength, bool bigEndian) {
	// Resize the file if necessary
	while (writePos + 4 > fileLength) {
		if (fileLength <= 0) {
			// Start at 16 bytes
			fileLength = 16;
		} else {
			// Double the amount of allocated memory every time we need to increase the size
			fileLength *= 2;
		}

		// Resize the file
		file = (uint8_t*) realloc(file, fileLength);
	}

	// Write out this value
	if (bigEndian) {
		file[writePos+0]	= (val>>24)&0xff;
		file[writePos+1]	= (val>>16)&0xff;
		file[writePos+2]	= (val>>8) &0xff;
		file[writePos+3]	= (val>>0) &0xff;
	} else {
		file[writePos+0]	= (val>>0) &0xff;
		file[writePos+1]	= (val>>8) &0xff;
		file[writePos+2]	= (val>>16)&0xff;
		file[writePos+3]	= (val>>24)&0xff;		
	}
}

/// \brief Retrieves a string associated with this binary file
int32_t output_binary::get_string(const string& value) {
	// Simple conversion to wide string (basically, assumes that the input string is ISO-8859-1)
	wstring wideString;
	for (string::const_iterator chr = value.begin(); chr != value.end(); ++chr) {
		wideString += (wchar_t) *chr;
	}

	// Return the entry in the string table for this value
	return get_string(wideString);
}

/// \brief Indicates that we're about to start writing out the table whose header offset is at the specified position
void output_binary::start_table(uint32_t offset) {
	// Position within the actual file (4 * the offset)
	int pos = offset * 4;

	// Write out the current write pos at this position
	write_int_raw((uint32_t) m_WritePos, m_File, pos, m_FileLength, m_BigEndian);
}

/// \brief Writes out an unsigned integer value
void output_binary::write_int(uint32_t value) {
	write_int_raw(value, m_File, m_WritePos, m_FileLength, m_BigEndian);
	m_WritePos += 4;
}

/// \brief Writes out a signed intger value
void output_binary::write_int(int32_t value) {
	write_int_raw((uint32_t) value, m_File, m_WritePos, m_FileLength, m_BigEndian);
	m_WritePos += 4;
}

/// \brief Writes out a string value
void output_binary::write_string(const std::wstring& value) {
	// TODO: implement me
}

/// =======
///  Lexer
/// =======

/// \brief Writes out the symbol map table
void output_binary::write_symbol_map() {
	// Build up a symbol table from the symbol sets generated by the parser
	symbol_table<wchar_t> symbolLevels;

	// Add the symbol range to our new set
	for (symbol_map_iterator symbolMap = begin_symbol_map(); symbolMap != end_symbol_map(); ++symbolMap) {
		symbolLevels.add_range(symbolMap->symbolRange, symbolMap->identifier);
	}

	// Convert to a hard-coded symbol table
	size_t 	size 	= 0;
	int*	table 	= symbolLevels.Table.to_hard_coded_table(size);

	// Write out the table
	start_table(table::symbol_map);
	write_int((uint32_t) size);

	for (size_t entry = 0; entry < size; ++entry) {
		write_int((int32_t) table[entry]);
	}
}

/// \brief Writes out the lexer DFA
void output_binary::write_lexer_dfa() {
	// Start the table
	start_table(table::lexer);

	// Write out the number of states
	uint32_t numStates = count_lexer_states();
	write_int(numStates);

	// Work out the offsets for each state
	uint32_t 	curOffset 	= m_WritePos;
	const ndfa*	dfa			= get_dfa();

	for (uint32_t stateId = 0; stateId < numStates; stateId++) {
		// Get the current state
		const state& thisState = dfa->get_state(stateId);

		// Offset is 0 if there are no transitions for this state
		if (thisState.count_transitions() == 0) {
			write_int(0u);
			continue;
		}

		// For other states, the offset is in curOffset
		write_int(curOffset);

		// Move the offset on. First, there's 4 bytes for the transition count
		// (This is inefficient as most states will have < 255 transitions but
		// I want a format that can be used directly by a parser)
		curOffset += 4;

		// Next, there's 4 bytes per transition
		curOffset += 4 * thisState.count_transitions();
	}

	// Write out the transitions themselves
	for (uint32_t stateId = 0; stateId < numStates; stateId++) {
		// Get the current state
		const state& thisState = dfa->get_state(stateId);

		// Nothing to write if there are no transitions for this state
		if (thisState.count_transitions() == 0) {
			continue;
		}

		// Write out the number of transitions
		write_int((uint32_t) thisState.count_transitions());

		// Write out the transitions themselves
		bool shownError = false;

		for (state::iterator transit = thisState.begin(); transit != thisState.end(); transit++) {
			// Get the symbol set and target state of this transition
			int symSet 		= transit->symbol_set();
			int targetState	= transit->new_state();

			// We only support 65535 symbol sets/65535 states
			// (Lexers that use more than this are going to be *HUGE* and will likely have hit other system limits before we get here)
			if (symSet > 65535 && !shownError) {
				cons().report_error(error(error::sev_error, filename(), L"OUT_OF_BOUNDS_SYMBOL_SET", L"Too many symbol sets", position()));
				shownError 	= true;
				m_Errored	= true;
			}
			if (targetState > 65534) {
				cons().report_error(error(error::sev_error, filename(), L"OUT_OF_BOUNDS_TARGET_STATE", L"Too many lexer states", position()));
				shownError 	= true;
				m_Errored	= true;
			}

			// Generate the entry
			uint32_t entry = ((uint32_t)symSet)<<16;
			if (targetState < 0) {
				entry |= 0xffffu;
			} else {
				entry |= (uint32_t)targetState;
			}

			// Write it out
			write_int(entry);
		}
	}
}

/// =============
///  Compilation
/// =============

/// \brief Compiles the parser specified by this stage
void output_binary::compile() {
	// Allocate space for the header and offsets table
	m_FileLength = m_WritePos = 0;

	// No errors yet
	m_Errored = false;

	// Write out the header
	write_int(header::format_indicator);
	write_int(header::format_version);
	write_int(get_string(language_name()));
	write_int((version::major_version<<16) | (version::minor_version<<8) | (version::revision<<0));
	write_int(get_string(version::version_string));
	for (int unsetHeader = 0; unsetHeader<1; ++unsetHeader) {
		write_int(0xffffffffu);
	}

	// Write out a blank offset table
	for (int offset = 0; offset < 16; ++offset) {
		write_int(0u);
	}

	// Write out the lexer
	write_symbol_map();
	write_lexer_dfa();

	// Write the final binary file
	if (!m_Errored) {
		std::ostream* outputFile = cons().open_binary_file_for_writing(m_TargetFilename);
		if (outputFile) {
			outputFile->write((const char*) m_File, (streamsize) m_WritePos);

			outputFile->flush();
			delete outputFile;
		}
	}
}
