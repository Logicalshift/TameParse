//
//  binary.h
//  TameParse
//
//  Created by Andrew Hunter on 06/02/2012.
//  Copyright (c) 2012 Andrew Hunter. All rights reserved.
//

#ifndef _COMPILER_OUTPUT_BINARY_H
#define _COMPILER_OUTPUT_BINARY_H

#include "TameParse/Compiler/output_stage.h"

namespace compiler {
    ///
    /// \brief Produces a binary file containing the parser and lexer tables
    ///
    /// The output file is designed to be used directly as the tables for a parser 
    /// implementation. This class supports both big and little-endian output.
    ///
    /// File format is as follows:
    ///
    /// All offsets are in words (32-bits, 4 bytes) from file beginning; an offset of
    /// 0 indicates that a table is not present.
    ///
    /// Header (16 words):
    ///    1 word: file format/endian indicator 'TPar' (0x54506172)
    ///    1 word: file format version number (0x100)
    ///	   1 word: string ID containing the language name
    ///	   1 word: TameParse version (major<<16 | minor<<8 | revision<<0)
    ///    1 word: string ID containing the TameParse version information
    ///    11 words: reserved (written as 0xffffffff)
    ///
    /// Offset tables:
    ///    1 word: offset to strings table
    ///
    ///    1 word: offset to symbol map
    ///    1 word: offset to lexer state machine
    ///
    ///    1 word: offset to terminal action table
    ///    1 word: offset to nonterminal action table
    ///    1 word: offset to guard ending state table
    ///    1 word: offset to rule symbol count table
    ///    1 word: offset to weak to strong symbol table
    ///
    ///    1 word: offset to rule definition table
    ///    1 word: offset to terminal name table
    ///    1 word: offset to nonterminal name table
    ///
    class output_binary : public output_stage {
    private:

    public:
        ///
        /// \brief Offsets and other definitions for the binary file header
        ///
        class header {
        public:
            /// \brief File format indicator
            static const unsigned int format_indicator = 0x54506172;

            /// \brief File format version number
            static const unsigned int format_version = 0x100;

            /// \brief Total number of words in the header
            static const unsigned int length = 16;

            /// \brief Offset to the file indicator word
            static const unsigned int indicator = 0;

            /// \brief Header word containin the format_version constant
            static const unsigned int version = 1;

            /// \brief Header word containing the string ID of the name of the language
            static const unsigned int name = 2;

            /// \brief Header word containing the version number of TameParse that this was generated by
            static const unsigned int generator_version = 3;

            /// \brief Header word containing a string ID identifying the generator for this file
            static const unsigned int generator_version_string = 4;
        };

        ///
        /// \brief Locations for the table offsets (after the header)
        ///
        class table {
            /// \brief Offset to the strings table
            static const unsigned int strings = header::length + 0;

            /// \brief Offset to the symbol map table
            static const unsigned int symbol_map = header::length + 1;

            /// \brief Offset to the lexer state machine definition
            static const unsigned int lexer = header::length + 2;

            /// \brief Offset to the terminal actions table
            static const unsigned int terminal_actions = header::length + 3;

            /// \brief Offset to the nonterminal actions table
            static const unsigned int nonterminal_actions = header::length + 4;

            /// \brief Offset to the guard ending state table
            static const unsigned int guard_endings = header::length + 5;

            /// \brief Offset to the rule symbol table
            static const unsigned int rule_symbol = header::length + 6;

            /// \brief Offset to the weak-to-strong symbol mapping table
            static const unsigned int weak_to_strong = header::length + 7;

            /// \brief Offset to the rule definitions table
            static const unsigned int rule_definitions = header::length + 8;

            /// \brief Offset to the terminal names table
            static const unsigned int terminal_names = header::length + 9;

            /// \brief Offset to the nonterminal names table
            static const unsigned int nonterminal_names = header::length + 10;
        };
    };
}

#endif
