//
// Simple JSON formatter, reads from stdin and writes a pretty-printed version 
// to stdout
//

#include <iostream>
#include <string>
#include "json.h"

using namespace std;

void pretty_print(const yy_JSON::yy_Object_n* obj, int indentAmount = 0);
void pretty_print(const yy_JSON::yy_Value_n* value, int indentAmount);

//
// Parses stdin as JSON and pretty prints it to stdout
//
int main(int argc, const char** argv) {
    // Create the parser - unicode from wcin
    yy_JSON::state* parser = yy_JSON::create_yy_Object<wchar_t>(wcin);

    // Generate the AST
    bool success = parser->parse();

    if (!success) {
        // Report syntax error
        if (parser->look().item()) {
            // The lookahead contains the symbol that generated the error
            cerr << "Syntax error on line " << parser->look()->pos().line() << ", column " << parser->look()->pos().column() << endl;
        } else {
            // No lookahead: file is incomplete
            cerr << "Syntax error: unexpected end of file" << endl;
        }

        // Abort if there's an error
        return 1;
    }

    // Retrieve the AST
    // A future version will provide a nicer API for this: this reads the symbol on top of the parse stack
    const yy_JSON::yy_Object_n* root = static_cast<const yy_JSON::yy_Object_n*>(parser->get_item().item());

    // Pretty-print the result
    wcout << endl;
    pretty_print(root);
    wcout << endl;

    // Exit success
    return 0;
}

// ===
// A fairly simple JSON pretty printer
// ===

wstring indent(int amount) {
    if (amount > 0) {
        return wstring(amount, L' ');
    } else {
        return wstring();
    }
}

void pretty_print(const yy_JSON::yy_Array_n* array, int indentAmount) {
    wcout << L"[";

    if (array->yy_first) {
        // First array element
        wcout << endl << indent(indentAmount+2);
        pretty_print(array->yy_first, indentAmount+2);

        // Remainder of the elements
        // Using 'auto' would be sensible here, but we'll do it the old-fashioned way
        // (',' Value)* generates a AST type of 'list_of__comma__Value_n'
        for (yy_JSON::yy_list_of__comma__Value_n::iterator value = array->yy_remainder->begin(); value != array->yy_remainder->end(); ++value) {
            wcout << L"," << endl << indent(indentAmount+2);
            pretty_print((*value)->yy_Value, indentAmount+2);
        }
    }

    wcout << L"]";
}

void pretty_print(const yy_JSON::yy_Value_n* value, int indentAmount) {
    // Print the various different items that can be in a value
    // The _2 names are generated by the tool to avoid clashes with other objects
    if (value->yy_string) {
        wcout << value->yy_string->content<wchar_t>();
    } else if (value->yy_number) {
        wcout << value->yy_number->content<wchar_t>();
    } else if (value->yy_true) {
        wcout << L"true";
    } else if (value->yy_false) {
        wcout << L"false";
    } else if (value->yy_null) {
        wcout << L"null";
    } else if (value->yy_Object) {
        pretty_print(value->yy_Object, indentAmount);
    } else if (value->yy_Array) {
        pretty_print(value->yy_Array, indentAmount);
    }
}

void pretty_print(const yy_JSON::yy_Pair_n* pair, int indentAmount) {
    wcout << pair->yy_name->content<wchar_t>() << L": ";
    pretty_print(pair->yy_value, indentAmount+2);
}

void pretty_print(const yy_JSON::yy_Object_n* obj, int indentAmount) {
    wcout << L"{";

    // obj->first indicates the presence of a list of objects
    if (obj->yy_first) {
        wcout << endl << indent(indentAmount+2);
        pretty_print(obj->yy_first, indentAmount+2);

        for (yy_JSON::yy_list_of__comma__Pair_n::iterator pair = obj->yy_pairs->begin(); pair != obj->yy_pairs->end(); ++pair) {
            wcout << L"," << endl << indent(indentAmount+2);
            pretty_print((*pair)->yy_Pair, indentAmount + 2);
        }        

        wcout << endl << indent(indentAmount);
    }

    wcout << L"}";
}
