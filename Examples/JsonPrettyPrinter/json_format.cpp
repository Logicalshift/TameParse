//
// Simple JSON formatter, reads from stdin and writes a pretty-printed version 
// to stdout
//

#include <iostream>
#include <string>
#include "json.h"

using namespace std;

void pretty_print(const JSON::Object_n* obj, int indentAmount = 0);
void pretty_print(const JSON::Value_n* value, int indentAmount);

//
// Parses stdin as JSON and pretty prints it to stdout
//
int main(int argc, const char** argv) {
    // Create the parser - unicode from wcin
    JSON::state* parser = JSON::create_Object<wchar_t>(wcin);

    // Generate the AST
    bool success = parser->parse();

    if (!success) {
        // Report syntax error
        if (parser->look().item()) {
            // The lookahead contains the symbol that generated the error
            cerr << "Syntax error on line " << parser->look()->pos().line() << ", column " << parser->look()->pos().column() << endl;
        } else {
            // No lookahead: file is incomplete
            cerr << "Syntax error: unexpected end of file" << endl;
        }

        // Abort if there's an error
        return 1;
    }

    // Retrieve the AST
    // A future version will provide a nicer API for this: this reads the symbol on top of the parse stack
    const JSON::Object_n* root = static_cast<const JSON::Object_n*>(parser->get_item().item());

    // Pretty-print the result
    wcout << endl;
    pretty_print(root);
    wcout << endl;

    // Exit success
    return 0;
}

// ===
// A fairly simple JSON pretty printer
// ===

wstring indent(int amount) {
    if (amount > 0) {
        return wstring(amount, L' ');
    } else {
        return wstring();
    }
}

void pretty_print(const JSON::Array_n* array, int indentAmount) {
    wcout << L"[";

    if (array->first) {
        // First array element
        wcout << endl << indent(indentAmount+2);
        pretty_print(array->first, indentAmount+2);

        // Remainder of the elements
        // Using 'auto' would be sensible here, but we'll do it the old-fashioned way
        // (',' Value)* generates a AST type of 'list_of__comma__Value_n'
        for (JSON::list_of__comma__Value_n::iterator value = array->remainder->begin(); value != array->remainder->end(); ++value) {
            wcout << L"," << endl << indent(indentAmount+2);
            pretty_print((*value)->Value, indentAmount+2);
        }
    }

    wcout << L"]";
}

void pretty_print(const JSON::Value_n* value, int indentAmount) {
    // Print the various different items that can be in a value
    // The _2 names are generated by the tool to avoid clashes with other objects
    if (value->string_2) {
        wcout << value->string_2->content<wchar_t>();
    } else if (value->number) {
        wcout << value->number->content<wchar_t>();
    } else if (value->true_2) {
        wcout << L"true";
    } else if (value->false_2) {
        wcout << L"false";
    } else if (value->null) {
        wcout << L"null";
    } else if (value->Object) {
        pretty_print(value->Object, indentAmount);
    } else if (value->Array) {
        pretty_print(value->Array, indentAmount);
    }
}

void pretty_print(const JSON::Pair_n* pair, int indentAmount) {
    wcout << pair->name->content<wchar_t>() << L": ";
    pretty_print(pair->value, indentAmount+2);
}

void pretty_print(const JSON::Object_n* obj, int indentAmount) {
    wcout << L"{";

    // obj->first indicates the presence of a list of objects
    if (obj->first) {
        wcout << endl << indent(indentAmount+2);
        pretty_print(obj->first, indentAmount+2);

        for (JSON::list_of__comma__Pair_n::iterator pair = obj->pairs->begin(); pair != obj->pairs->end(); ++pair) {
            wcout << L"," << endl << indent(indentAmount+2);
            pretty_print((*pair)->Pair, indentAmount + 2);
        }        

        wcout << endl << indent(indentAmount);
    }

    wcout << L"}";
}
