//
//  cplusplus.cpp
//  Parse
//
//  Created by Andrew Hunter on 29/08/2011.
//  Copyright 2011 __MyCompanyName__. All rights reserved.
//

#include <time.h>
#include <sstream>
#include <algorithm>

#include "Compiler/OutputStages/cplusplus.h"

using namespace std;
using namespace dfa;
using namespace compiler;

/// \brief Creates a new output stage
output_cplusplus::output_cplusplus(console_container& console, const std::wstring& filename, lexer_stage* lexer, language_stage* language, lr_parser_stage* parser, const std::wstring& filenamePrefix, const std::wstring& className, const std::wstring& namespaceName)
: output_stage(console, filename, lexer, language, parser)
, m_FilenamePrefix(filenamePrefix)
, m_ClassName(className)
, m_Namespace(namespaceName)
, m_SourceFile(NULL)
, m_HeaderFile(NULL)
, m_SymbolLevels(NULL) {
}

/// \brief Destructor
output_cplusplus::~output_cplusplus() {
	if (m_SourceFile) 	delete m_SourceFile;
	if (m_HeaderFile) 	delete m_HeaderFile;
	if (m_SymbolLevels) delete m_SymbolLevels;
}

/// \brief Converts a string to upper case
static string toupper(const string& s) {
	string res = s;
    for (string::iterator c = res.begin(); c != res.end(); c++) {
        *c = std::toupper(*c);
    }
	return res;
}

/// \brief Returns a valid C++ identifier for the specified symbol name
std::string output_cplusplus::get_identifier(const std::wstring& name) {
	// Empty string if the name is empty
	if (name.size() == 0) return "_";

	// Strip out any quotes that the name might have
	wstring stripped;

	if (name[0] == L'\'' && name[name.size()-1] == L'\'') {
		stripped = name.substr(1, name.size()-2);
	}

	else if (name[0] == L'"' && name[name.size()-1] == L'"') {
		stripped = name.substr(1, name.size()-2);
	}

	else if (name[0] == L'<' && name[name.size()-1] == L'>') {
		stripped = name.substr(1, name.size()-2);
	}

	else {
		stripped = name;
	}

	stringstream res;
	for (wstring::const_iterator wideChar = stripped.begin(); wideChar != stripped.end(); wideChar++) {
		// Just append values that are valid C++ identifiers
        wchar_t c = *wideChar;
		if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || (res.tellp() > 0 && c >= '0' && c <= '9')) {
			res << (char) c;
			continue;
		}

		// Some punctuation characters are written out as names
		switch (c) {
			case L'<':	res << "_lessthan_"; break;
			case L'>':	res << "_greaterthan_"; break;
			case L'\'':	res << "_quote_"; break;
			case L'"':	res << "_doublequote_"; break;
			case L'&':	res << "_ampersand_"; break;
			case L':':	res << "_colon_"; break;
			case L'=':	res << "_equals_"; break;
			case L'!':	res << "_exclamation_"; break;
			case L'@':	res << "_at_"; break;
			case L'#':	res << "_hash_"; break;
			case L'$':	res << "_dollar_"; break;
			case L'%':	res << "_percent_"; break;
			case L'^':	res << "_cicumflex_"; break;
			case L'*':	res << "_star_"; break;
			case L'(':	res << "_openparen_"; break;
			case L')':	res << "_closeparen_"; break;
			case L'+':	res << "_plus_"; break;
			case L'/':	res << "_slash_"; break;
			case L'\\':	res << "_backslash_"; break;
			case L'|':	res << "_pipe_"; break;
			case L';':	res << "_semicolon_"; break;
			case L'.':	res << "_dot_"; break;
			case L',':	res << "_comma_"; break;
			case L'?':	res << "_question_"; break;
			case L'~':	res << "_tilde_"; break;
            case L'_':  res << "_"; break;
            case L'{':  res << "_opencurly_"; break;
            case L'}':  res << "_closecurly_"; break;
            case L'[':  res << "_opensquare_"; break;
            case L']':  res << "_closesquare_"; break;

            case L'-':	
                // Bit weird, the language encourages users to use this as part of identifiers
                if (stripped.size() == 1) {
                    res << "_minus_"; 
                } else {
                    res << "_";
                }
                break;

			default:
				// We use '_' as a placeholder for everything else
				res << "_";
				break;
		}
	}
    
    // Produce the final result
    return res.str();
}

/// \brief Writes out a header to the specified file
void output_cplusplus::write_header(const std::wstring& filename, std::ostream* target) {
    // Get the current time
    char        timeString[128];
    time_t      nowTime     = time(NULL);
    struct tm*  nowLocal    = localtime(&nowTime);
    
    strftime(timeString, 127, "%a %Y/%m/%d %H:%M:%S", nowLocal);
    
	(*target) << "///\n";
	(*target) << "/// " << cons().convert_filename(filename) << "\n";
	(*target) << "/// Parser file generated by TameParse at " << timeString << "\n";
	(*target) << "///\n\n";
}

/// \brief About to begin writing out output
void output_cplusplus::begin_output() {
	// Clean up if there are existing files for any reasom
	if (m_SourceFile) delete m_SourceFile;
	if (m_HeaderFile) delete m_HeaderFile;

	m_SourceFile = NULL;
	m_HeaderFile = NULL;

	// Create the source files
	wstring sourceFilename = m_FilenamePrefix + L".cpp";
	wstring headerFilename = m_FilenamePrefix + L".h";

	// Open the files for writing
	m_SourceFile = cons().open_binary_file_for_writing(sourceFilename);
	m_HeaderFile = cons().open_binary_file_for_writing(headerFilename);

	// TODO: check for errors (file streams will be NULL)

	// Write out a header
	write_header(sourceFilename, m_SourceFile);
	write_header(headerFilename, m_HeaderFile);

	// Write out the boilerplate at the start of the header (declare the class)
	(*m_HeaderFile) << "#ifndef TAMEPARSE_PARSER_" << toupper(get_identifier(m_FilenamePrefix)) << "\n";
	(*m_HeaderFile) << "#define TAMEPARSE_PARSER_" << toupper(get_identifier(m_FilenamePrefix)) << "\n";
    (*m_HeaderFile) << "\n";

    (*m_HeaderFile) << "#include \"Dfa/lexer.h\"\n";
    (*m_HeaderFile) << "#include \"Lr/parser.h\"\n";
    (*m_HeaderFile) << "#include \"Lr/parser_tables.h\"\n";
    (*m_HeaderFile) << "\n";
    
    if (!m_Namespace.empty()) {
        (*m_HeaderFile) << "namespace " << get_identifier(m_Namespace) << " {\n";
    }
    (*m_HeaderFile) << "class " << get_identifier(m_ClassName) << " {\n";
    
    // Write out the boilerplate at the start of the source file (include the header)
    (*m_SourceFile) << "#include \"" << cons().convert_filename(headerFilename) << "\"\n";

    if (!m_Namespace.empty()) {
        (*m_SourceFile) << "using namespace " << get_identifier(m_Namespace) << ";\n";
    }
}

/// \brief Finishing writing out output
void output_cplusplus::end_output() {
    // Finish off the header file
    (*m_HeaderFile) << "\n";
    (*m_HeaderFile) << "};\n";            // End of class
    if (!m_Namespace.empty()) {
        (*m_HeaderFile) << "}\n";         // End of namespace
    }

    (*m_HeaderFile) << "\n#endif\n";	  // End of the conditional
}

/// \brief The output stage is about to produce a list of terminal symbols
void output_cplusplus::begin_terminal_symbols() {
    // Create a public class to contain the list of terminal identifiers
    (*m_HeaderFile) << "\npublic:\n";
    (*m_HeaderFile) << "    class t {\n";
    (*m_HeaderFile) << "    public:\n";
}

/// \brief Specifies the identifier for the terminal symbol with a given name
void output_cplusplus::terminal_symbol(const std::wstring& name, int identifier) {
    // Get the short name
    string       shortName = get_identifier(name);
    
    // Choose a unique name (gets a bit weird if we chose a unique name that later clashes)
    stringstream ourName;
    
    ourName << shortName;
    int count = m_TerminalSymbolCount[shortName];
    
    while (m_TerminalSymbolCount[ourName.str()] > 0) {
        ourName << "_" << count;
    }

    m_TerminalSymbolCount[shortName]++;

    // Output a constant for this terminal
    (*m_HeaderFile) << "        static const int " << ourName.str() << " = " << identifier << ";\n";
}

/// \brief Finished writing out the terminal symbols
void output_cplusplus::end_terminal_symbols() {
    (*m_HeaderFile) << "    };\n";
}

/// \brief The output stage is about to produce a list of non-terminal symbols
void output_cplusplus::begin_nonterminal_symbols() {
    // Create a public class to contain the list of nonterminal identifiers
    (*m_HeaderFile) << "\npublic:\n";
    (*m_HeaderFile) << "    class nt {\n";
    (*m_HeaderFile) << "    public:\n";
}

/// \brief Specifies the identifier for the non-terminal symbol with a given name
void output_cplusplus::nonterminal_symbol(const std::wstring& name, int identifier) {
    // Get the short name
    string       shortName = get_identifier(name);
    
    if (name.empty()) {
        // Some nonterminals don't have a name
        shortName = "_unnamed";
    }
    
    // Choose a unique name (gets a bit weird if we chose a unique name that later clashes)
    stringstream ourName;
    
    ourName << shortName;
    int count = m_NonterminalSymbolCount[shortName];
    
    while (m_NonterminalSymbolCount[ourName.str()] > 0) {
        ourName << "_" << count;
    }
    
    m_NonterminalSymbolCount[shortName]++;
    
    // Output a constant for this terminal
    (*m_HeaderFile) << "        static const int " << ourName.str() << " = " << identifier << ";\n";
}

/// \brief Finished writing out the terminal symbols
void output_cplusplus::end_nonterminal_symbols() {
    (*m_HeaderFile) << "    };\n";
}

/// \brief Starting to write out the symbol map for the lexer
void output_cplusplus::begin_lexer_symbol_map(int maxSetId) {
	// TODO: support symbol maps for alphabets other than wchar_t

	// Write out the number of symbol sets
	(*m_HeaderFile) << "\npublic:\n";
	(*m_HeaderFile) << "    static const int number_of_symbol_sets = " << maxSetId << ";\n";

	// Include the hard-coded symbol table in the source file
	(*m_SourceFile) << "\n#include \"Dfa/hard_coded_symbol_table.h\"\n";

	// Begin building the symbol levels object
	if (m_SymbolLevels) {
		delete m_SymbolLevels;
	}
	m_SymbolLevels = new symbol_table<wchar_t>();
}

/// \brief Specifies that a given range of symbols maps to a particular identifier
void output_cplusplus::symbol_map(const dfa::range<int>& symbolRange, int identifier) {
	// Just add to the symbol levels
	m_SymbolLevels->add_range(symbolRange, identifier);
}

/// \brief Finishing writing out the symbol map for the lexer
void output_cplusplus::end_lexer_symbol_map() {
	// Begin writing out the symbol map table
	(*m_SourceFile) << "\nstatic const int s_SymbolMapTable[] = {";

	// Convert to a hard-coded table
	size_t	size;
	int* 	hcst = m_SymbolLevels->Table.to_hard_coded_table(size);

	// Write it out
	for (size_t tablePos = 0; tablePos < size; tablePos++) {
		// Add newlines
		if ((tablePos % 10) == 0) {
			(*m_SourceFile) << "\n        ";
		}

		// Write out this entry
		(*m_SourceFile) << dec << hcst[tablePos];
		if (tablePos+1 < size) {
			(*m_SourceFile) << ", ";
		}
	}

	// Finished with the table
	delete[] hcst;

	// Finished the table
	(*m_SourceFile) << "\n    };\n";
    
    // Add the symbol table class
    (*m_SourceFile) << "\nstatic const dfa::hard_coded_symbol_table<wchar_t, 2> s_SymbolMap(s_SymbolMapTable);\n";
}

/// \brief About to begin writing out the lexer tables
void output_cplusplus::begin_lexer_state_machine(int numStates) {
	// Write out the number of states to the header file
	(*m_HeaderFile) << "\n        static const int number_of_lexer_states = " << numStates << ";\n";

	// Need to include the state machine class
	(*m_SourceFile) << "\n#include \"Dfa/state_machine.h\"\n";

	// Begin writing out the state machine table
	// TODO: support table styles other than 'compact' (the flat table is faster for all character types and more compact for some lexer types)
	(*m_SourceFile) << "\nstatic const dfa::state_machine_compact_table<false>::entry s_LexerStateMachine[] = {\n";

	// Reset the 
	m_LexerEntryPos = 0;
}

/// \brief Starting to write out the transitions for a given state
void output_cplusplus::begin_lexer_state(int stateId) {
	// Write out a comment
	(*m_SourceFile) << "\n\n        // State " << stateId << "\n        ";

	// Remember the current state
	m_LexerCurrentState = stateId;

	// Record its position
	m_StateToEntryOffset.push_back(m_LexerEntryPos);
}

/// \brief Adds a transition for the current state
void output_cplusplus::lexer_state_transition(int symbolSet, int newState) {
	// Write out a separator
	if (m_LexerEntryPos > 0) {
		(*m_SourceFile) << ", ";
		if ((m_LexerEntryPos%10) == 0) {
			(*m_SourceFile) << "\n        ";
		}
	}

	// Write out this transition
	(*m_SourceFile) << "{ " << symbolSet << ", " << newState << " }";

	// Update the lexer state position
	m_LexerEntryPos++;
}

/// \brief Finishes writing out a lexer state
void output_cplusplus::end_lexer_state() {
	// Nothing to do
}

/// \brief Finished writing out the lexer table
void output_cplusplus::end_lexer_state_machine() {
	// Finish off the table
	(*m_SourceFile) << "\n    };\n";
}

/// \brief About to write out the list of accepting states for a lexer
void output_cplusplus::begin_lexer_accept_table() {
	// Start the accepting action tables
	(*m_SourceFile) << "\nstatic const int s_AcceptingStates[] = {\n        ";
}

/// \brief The specified state is not an accepting state
void output_cplusplus::nonaccepting_state(int stateId) {
	if (stateId > 0) {
		(*m_SourceFile) << ", ";
	}

	// Non-accepting states get -1 as the action
	(*m_SourceFile) << "-1";
}

/// \brief The specified state is an accepting state
void output_cplusplus::accepting_state(int stateId, int acceptSymbolId) {
	if (stateId > 0) {
		(*m_SourceFile) << ", ";
	}

	// Write out the action for this state
	(*m_SourceFile) << acceptSymbolId;
}

/// \brief Finished the lexer acceptance table
void output_cplusplus::end_lexer_accept_table() {
	// Finish up the acceptance table
	(*m_SourceFile) << "\n    };\n";
}

/// \brief Finished all of the lexer definitions
void output_cplusplus::end_lexer_definitions() {
	// Add a final state to point to the end of the array
	m_StateToEntryOffset.push_back(m_LexerEntryPos);

	// Write out the rows table
	(*m_SourceFile) << "\nstatic const dfa::state_machine_compact_table<false>::entry* s_LexerStates[" << m_StateToEntryOffset.size()-1 << "] = {\n        ";

	// Write the actual rows
	bool first = true;
	for (vector<int>::iterator offset = m_StateToEntryOffset.begin(); offset != m_StateToEntryOffset.end()-1; offset++) {
		// Commas between entries
		if (!first) (*m_SourceFile) << ", ";

		// Entries point to a position in the state machine table
		(*m_SourceFile) << "s_LexerStateMachine + " << *offset;

		// No longer the first entry
		first = false;
	}

	(*m_SourceFile) << "\n    };\n";

	// Create a state machine
	(*m_SourceFile) << "\ntypedef dfa::state_machine_tables<wchar_t, dfa::hard_coded_symbol_table<wchar_t, 2> > lexer_state_machine;\n";
	(*m_SourceFile) << "static const lexer_state_machine s_StateMachine(s_SymbolMap, s_LexerStates, " << m_StateToEntryOffset.size()-1 << ");\n";

	// Create the lexer itself
	(*m_SourceFile) << "\ntypedef dfa::dfa_lexer_base<const lexer_state_machine&, 0, 0, false> lexer_definition;\n";
	(*m_SourceFile) << "static lexer_definition s_LexerDefinition(s_StateMachine, " << m_StateToEntryOffset.size()-1 << ", s_AcceptingStates);\n";

	// Finally, the lexer class itself
	(*m_HeaderFile) << "\npublic:\n";
	(*m_HeaderFile) << "    static const dfa::lexer lexer;\n";

	(*m_SourceFile) << "\nconst dfa::lexer " << get_identifier(m_ClassName) << "::lexer(&s_LexerDefinition, false);\n";
}

/// \brief Starting to write out the definitions associated with the parser
void output_cplusplus::begin_parser_definitions() {
}

/// \brief Type of an action
typedef lr::parser_tables::action action;

/// \brief Writes out an action table
template<typename get_count> void write_action_table(string tableName, const lr::parser_tables::action* const* actionTable, const lr::parser_tables& tables, ostream& output) {
	// Count getter object
	get_count gc;

	// Start the table
	output << "static lr::parser_tables::action " << tableName << "_data[] = {";

	// Iterate through the states
	bool first = true;
	int count = 0;
	for (int state = 0; state < tables.count_states(); state++) {
		// Add the actions for this state
		int numActions = gc(tables, state);

		// Write out each action for this state
		for (int actionId = 0; actionId < numActions; actionId++) {
			// Comma if this is not the first item
			if (!first) {
				output << ", ";
			}

			// Add newlines for formatting
			if ((count%5) == 0) {
				output << "\n    ";
			}

			// Write out this action
			const action& thisAction = actionTable[state][actionId];
			output << "{ " << thisAction.m_Type << ", " << thisAction.m_NextState << ", " << thisAction.m_SymbolId << " }";

			// Move on
			first = false;
			count++;
		}
	}
	output << "\n};\n";
    
    // Output the final table
    output << "static lr::parser_tables::action* " << tableName << "[] = {";

    int pos = 0;
	count   = 0;
    first   = true;
    
	for (int state = 0; state < tables.count_states(); state++) {
        // Comma if this is not the first item
        if (!first) {
            output << ", ";
        }
        
        // Add newlines for formatting
        if ((count%3) == 0) {
            output << "\n    ";
        }

        // Output this state
        output << tableName << "_data + " << pos;
        
		// Add the actions for this state
		int numActions = gc(tables, state);
        pos += numActions;
        
        // Move on
        count++;
        first = false;
	}
    
    output << "\n};\n";
}

/// \brief Functor that returns the number of actions for a given terminal object
class count_terminal_actions {
public:
	int operator()(const lr::parser_tables& tables, int state) {
		return tables.action_counts()[state].m_NumTerms;
	}	
};

/// \brief Functor that returns the number of actions for a given non-terminal object
class count_nonterminal_actions {
public:
	int operator()(const lr::parser_tables& tables, int state) {
		return tables.action_counts()[state].m_NumNonterms;
	}	
};

/// \brief Supplies the parser tables generated by the compiler
void output_cplusplus::parser_tables(const lr::lalr_builder& builder, const lr::parser_tables& tables) {
    // True if we're at the first item
    bool    first;
    
    // Count used when writing tables
    int     count;
    
    // Need to include the parser tables file
    (*m_SourceFile) << "\n#include \"Lr/parser_tables.h\"\n";
    
	// Write out the terminal actions
    (*m_SourceFile) << "\n";
	write_action_table<count_terminal_actions>("s_TerminalActions", tables.terminal_actions(), tables, *m_SourceFile);
    
    // ... and the nonterminal actions
    (*m_SourceFile) << "\n";
	write_action_table<count_nonterminal_actions>("s_NonterminalActions", tables.nonterminal_actions(), tables, *m_SourceFile);
    
    // Write out the action counts
    (*m_SourceFile) << "\nstatic lr::parser_tables::action_count s_ActionCounts[] = {";
    
    first   = true;
    count   = 0;
    for (int stateId=0; stateId < tables.count_states(); stateId++) {
        // Comma
        if (!first) {
            (*m_SourceFile) << ", ";
        }

        // Newline
        if ((count%5) == 0) {
            (*m_SourceFile) << "\n    ";
        }
        
        // Write out the next item
        (*m_SourceFile) << "{ " << tables.action_counts()[stateId].m_NumTerms << ", " << tables.action_counts()[stateId].m_NumNonterms << " }";
        
        // Move on
        first = false;
        count++;
    }
    
    (*m_SourceFile) << "\n};\n";
    
    // Write out the end guard states
    (*m_SourceFile) << "\nstatic int s_EndGuardStates[] = {";
    
    first   = true;
    count   = 0;
    for (int stateId=0; stateId < tables.count_end_of_guards(); stateId++) {
        // Comma
        if (!first) {
            (*m_SourceFile) << ", ";
        }
        
        // Newline
        if ((count%20) == 0) {
            (*m_SourceFile) << "\n    ";
        }
        
        // Write out the next item
        (*m_SourceFile) << tables.end_of_guard_states()[stateId];
        
        // Move on
        first = false;
        count++;
    }
    
    (*m_SourceFile) << "\n};\n";

    // Write out the reduce rules
    (*m_SourceFile) << "\nstatic lr::parser_tables::reduce_rule s_ReduceRules[] = {";
    
    first   = true;
    count   = 0;
    for (int ruleId=0; ruleId < tables.count_reduce_rules(); ruleId++) {
        // Comma
        if (!first) {
            (*m_SourceFile) << ", ";
        }
        
        // Newline
        if ((count%5) == 0) {
            (*m_SourceFile) << "\n    ";
        }
        
        // Write out the next item
        const lr::parser_tables::reduce_rule& rule = tables.reduce_rules()[ruleId];
        (*m_SourceFile) << "{ " << rule.m_Identifier << ", " << rule.m_RuleId << ", " << rule.m_Length << " }";
        
        // Move on
        first = false;
        count++;
    }
    
    (*m_SourceFile) << "\n};\n";
    
    // Finally, the weak to strong equivalence table
    (*m_SourceFile) << "\nstatic lr::parser_tables::symbol_equivalent s_WeakToStrong[] = {";
    
    first   = true;
    count   = 0;
    for (int stateId=0; stateId < tables.count_weak_to_strong(); stateId++) {
        // Comma
        if (!first) {
            (*m_SourceFile) << ", ";
        }
        
        // Newline
        if ((count%10) == 0) {
            (*m_SourceFile) << "\n    ";
        }
        
        // Write out the next item
        (*m_SourceFile) << "{ " << tables.weak_to_strong()[stateId].m_OriginalSymbol << ", " << tables.weak_to_strong()[stateId].m_MappedTo << " }";
        
        // Move on
        first = false;
        count++;
    }
    
    (*m_SourceFile) << "\n};\n";
    
    // Generate the parser tables
    (*m_HeaderFile) << "\npublic:\n";
    (*m_HeaderFile) << "    static const lr::parser_tables lr_tables;\n";
    (*m_HeaderFile) << "    static const lr::simple_parser simple_parser;\n";
    
	(*m_SourceFile) << "\nconst lr::parser_tables " << get_identifier(m_ClassName) << "::lr_tables(" 
					<< tables.count_states() << ", " << tables.end_of_input() << ", " 
					<< tables.end_of_guard() 
					<< ", s_TerminalActions, s_NonterminalActions, s_ActionCounts, s_EndGuardStates, " 
					<< tables.count_end_of_guards() << ", " << tables.count_reduce_rules() << ", "
					<< "s_ReduceRules, " << tables.count_weak_to_strong() << ", "
					<< "s_WeakToStrong"
					<< ");\n";
	
	(*m_SourceFile) << "\nconst lr::simple_parser " << get_identifier(m_ClassName) << "::simple_parser(lr_tables);\n";
}

/// \brief Finished the parser definitions
void output_cplusplus::end_parser_definitions() {
}
