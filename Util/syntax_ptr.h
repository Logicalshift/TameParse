//
//  syntax_ptr.h
//  TameParse
//
//  Created by Andrew Hunter on 17/09/2011.
//  Copyright 2011 __MyCompanyName__. All rights reserved.
//

#ifndef _UTIL_SYNTAX_PTR_H
#define _UTIL_SYNTAX_PTR_H

#include <cstdlib>

namespace util {
    /// \brief auto_ptr like class used for pointers to items in an AST class generated by the parser
    ///
    /// auto_ptr does not automatically initialise objects to NULL, which is annoying for the parser generator
    /// as it doesn't know all the names of all the variables that will be generated when creating the constructor.
    /// This class does support this.
    ///
    /// Like auto_ptr, this will destroy its contents when it is itself destroyed, so it is subject to similar
    /// limitations when it comes to assignment.
    template<typename ptr_type> class syntax_ptr {
    private:
        /// \brief The value that is being pointed at
        ptr_type* m_Value;
        
        /// \brief No copying
        syntax_ptr(const syntax_ptr<ptr_type>& copyFrom);

        /// \brief Also, no assignment
        syntax_ptr<ptr_type>& operator=(const syntax_ptr<ptr_type>& assignFrom);
        
    public:
        /// \brief Default constructor, assigns the pointer to NULL
        inline syntax_ptr()
        : m_Value(NULL) {
        }
        
        /// \brief Set to a specific pointer value
        ///
        /// The pointer will be freed when this class is freed: it is invalid to assign a given pointer to more than
        /// one of these objects simultaneously.
        explicit inline syntax_ptr(ptr_type* value)
        : m_Value(value) {
        }
        
    public:
        /// \brief Converts this object back to its underlying type
        operator ptr_type*() { return m_Value; }

        /// \brief Converts this object back to its underlying type
        operator ptr_type*() const { return m_Value; }

        // Other operators
        
        ptr_type* operator->() { return m_Value; }
        const ptr_type* operator->() const { return m_Value; }
        ptr_type& operator*() { return *m_Value; }
        const ptr_type& operator*() const { return *m_Value; }
    };
}

#endif
